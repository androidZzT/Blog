{"meta":{"title":"ZzT's Blog","subtitle":"","description":"","author":"ZzT","url":"https://zzt.github.io","root":"/"},"pages":[],"posts":[{"title":"不定积分基本公式与推导","slug":"basic-integral","date":"2022-05-03T07:28:33.000Z","updated":"2022-05-03T07:54:26.673Z","comments":true,"path":"2022/05/03/basic-integral/","link":"","permalink":"https://zzt.github.io/2022/05/03/basic-integral/","excerpt":"","text":"不定积分基本公式与推导1∫ ax dx=axlna+C,(ax)′=axlna\\int\\ a^x\\,dx=\\dfrac{a^x}{lna} + C,\\quad ({a^x})&#x27; = a^x lna∫ axdx=lnaax​+C,(ax)′=axlna 2∫tan⁡x dx=∫sinxcosx dx=−∫1cosx d(cosx)=−ln⁡∣cos⁡x∣+C\\int\\tan x\\,dx=\\int\\dfrac{sinx}{cosx}\\,dx=-\\int\\dfrac{1}{cosx}\\,d(cosx)=-\\ln{|\\cos{x}|} + C∫tanxdx=∫cosxsinx​dx=−∫cosx1​d(cosx)=−ln∣cosx∣+C ∫cot⁡x dx=∫cosxsinx dx=−∫1sinx d(sinx)=ln⁡∣sin⁡x∣+C\\int\\cot x\\,dx=\\int\\dfrac{cosx}{sinx}\\,dx=-\\int\\dfrac{1}{sinx}\\,d(sinx)=\\ln{|\\sin{x}|} + C∫cotxdx=∫sinxcosx​dx=−∫sinx1​d(sinx)=ln∣sinx∣+C 3∫1cosx dx=∫sec⁡x dx=∫cosx(cosx)2 dx=∫cosx1−(sinx)2 dx=∫11−(sinx)2 d(sinx)=∫1(1+sinx)(1−sinx) d(sinx)=12[∫11+sinx d(sinx)−∫11−sinx d(sinx)]=12ln∣1+sinx1−sinx∣+C=12ln∣(1+sinx)2(cosx)2∣=ln∣1+sinxcosx∣=ln∣secx+tanx∣+C\\int\\dfrac{1}{cosx}\\,dx =\\int\\sec{x}\\,dx\\\\ =\\int\\dfrac{cosx}{(cosx)^2}\\,dx =\\int\\dfrac{cosx}{1-(sinx)^2}\\,dx \\\\ =\\int\\dfrac{1}{1-(sinx)^2}\\,d(sinx)=\\int\\dfrac{1}{(1+sinx)(1-sinx)}\\,d(sinx) \\\\ =\\dfrac{1}{2}[\\int\\dfrac{1}{1+sinx}\\,d(sinx) - \\int\\dfrac{1}{1-sinx}\\,d(sinx)] \\\\ =\\dfrac{1}{2}ln|\\dfrac{1+sinx}{1-sinx}| + C \\\\ =\\dfrac{1}{2}ln|\\dfrac{(1+sinx)^2}{(cosx)^2}|=ln|\\dfrac{1+sinx}{cosx}| \\\\ =ln|secx + tanx| + C∫cosx1​dx=∫secxdx=∫(cosx)2cosx​dx=∫1−(sinx)2cosx​dx=∫1−(sinx)21​d(sinx)=∫(1+sinx)(1−sinx)1​d(sinx)=21​[∫1+sinx1​d(sinx)−∫1−sinx1​d(sinx)]=21​ln∣1−sinx1+sinx​∣+C=21​ln∣(cosx)2(1+sinx)2​∣=ln∣cosx1+sinx​∣=ln∣secx+tanx∣+C ∫1sinx dx=∫csc⁡x dx=∫sinx(sinx)2 dx=∫sinx1−(cosx)2 dx=−∫11−(cosx)2 d(cosx)=−∫1(1+cosx)(1−cosx) d(cosx)=−12[∫11+cosx d(cosx+1)−∫11−cosx d(1−cosx)]=−12ln∣1+cosx1−cosx∣=−12ln(sinx)2(1−cosx)2=ln∣1−cosxsinx∣=ln∣cscx+cotx∣+C\\int\\dfrac{1}{sinx}\\,dx =\\int\\csc{x}\\,dx \\\\ =\\int\\dfrac{sinx}{(sinx)^2}\\,dx =\\int\\dfrac{sinx}{1-(cosx)^2}\\,dx \\\\ =-\\int\\dfrac{1}{1-(cosx)^2}\\,d(cosx)=-\\int\\dfrac{1}{(1+cosx)(1-cosx)}\\,d(cosx) \\\\ =-\\dfrac{1}{2}[\\int\\dfrac{1}{1+cosx}\\,d(cosx+1) - \\int\\dfrac{1}{1-cosx}\\,d(1-cosx)] \\\\ =-\\dfrac{1}{2}ln|\\dfrac{1+cosx}{1-cosx}| \\\\ =-\\dfrac{1}{2}ln\\dfrac{(sinx)^2}{(1-cosx)^2} \\\\ =ln|\\dfrac{1-cosx}{sinx}| \\\\ =ln|cscx + cotx| + C∫sinx1​dx=∫cscxdx=∫(sinx)2sinx​dx=∫1−(cosx)2sinx​dx=−∫1−(cosx)21​d(cosx)=−∫(1+cosx)(1−cosx)1​d(cosx)=−21​[∫1+cosx1​d(cosx+1)−∫1−cosx1​d(1−cosx)]=−21​ln∣1−cosx1+cosx​∣=−21​ln(1−cosx)2(sinx)2​=ln∣sinx1−cosx​∣=ln∣cscx+cotx∣+C 4∫(secx)2 dx=tanx+C,tanx′=(secx)2\\int (secx)^2\\,dx=tanx + C,\\quad tanx&#x27;=(secx)^2∫(secx)2dx=tanx+C,tanx′=(secx)2 ∫(cscx)2 dx=−cotx+C,cotx′=−(cscx)2\\int (cscx)^2\\,dx=-cotx +C,\\quad cotx&#x27;=-(cscx)^2∫(cscx)2dx=−cotx+C,cotx′=−(cscx)2 5∫secx tanx dx=∫sinx(cosx)2 dx=∫−1(cosx)2 d(cosx)=secx+C,(secx)′=secx tanx\\int secx \\; tanx\\, dx= \\int \\dfrac{sinx}{(cosx)^2}\\,dx=\\int-\\dfrac{1}{(cosx)^2}\\,d(cosx)=secx+C, \\quad (secx)&#x27;=secx\\;tanx∫secxtanxdx=∫(cosx)2sinx​dx=∫−(cosx)21​d(cosx)=secx+C,(secx)′=secxtanx ∫cscx cotx dx=∫cosx(sinx)2 dx=∫1(sinx)2 d(sinx)=−cscx+C,(cscx)′=cscx−cotx\\int cscx \\; cotx \\,dx = \\int\\dfrac{cosx}{(sinx)^2}\\,dx=\\int\\dfrac{1}{(sinx)^2}\\,d(sinx)=-cscx + C, \\quad (cscx)&#x27; = cscx - cotx∫cscxcotxdx=∫(sinx)2cosx​dx=∫(sinx)21​d(sinx)=−cscx+C,(cscx)′=cscx−cotx 6∫1a2+x2 dx=1aarctanxa+C\\int\\dfrac{1}{a^2 + x^2}\\,dx=\\dfrac{1}{a}arctan\\dfrac{x}{a} + C∫a2+x21​dx=a1​arctanax​+C ∫1a2−x2 dx=arcsinxa+C\\int\\dfrac{1}{\\sqrt{a^2 - x^2}}\\,dx=arcsin\\dfrac{x}{a} + C∫a2−x2​1​dx=arcsinax​+C 7三角函数换元∫1x2−a2 dx令 x=asect,dx=a sect tant dt=∫1atant asect tant dt=∫sect dt=ln∣sect+tant∣+C回代 xsect=xa,tant=x2−a2a=ln∣x+x2−a2∣−lna+C1=ln∣x+x2−a2∣+C\\int\\dfrac{1}{\\sqrt{x^2 - a^2}}\\,dx \\\\ 令\\; x=asect, \\quad dx=a\\;sect \\; tant \\; dt \\\\ =\\int \\dfrac{1}{atant} \\; asect \\; tant\\, dt \\\\ =\\int sect\\, dt \\\\ =ln|sect + tant| + C \\\\ 回代 \\; x sect=\\dfrac{x}{a} ,\\quad tant=\\dfrac{\\sqrt{x^2 - a^2}}{a} \\\\ =ln | x + \\sqrt{x^2 - a^2}| - lna + C_1 \\\\ =ln | x + \\sqrt{x^2 - a^2}| + C ∫x2−a2​1​dx令x=asect,dx=asecttantdt=∫atant1​asecttantdt=∫sectdt=ln∣sect+tant∣+C回代xsect=ax​,tant=ax2−a2​​=ln∣x+x2−a2​∣−lna+C1​=ln∣x+x2−a2​∣+C ∫1x2+a2 dx令 x=atant,dx=a (sect)2 dt=∫1asect a(sect)2,dt=∫sect dt=ln∣sect+tant∣+C回代 sect=x2+a2a tant=xa=ln∣x+x2+a2∣+C\\int\\dfrac{1}{\\sqrt{x^2 + a^2}}\\,dx \\\\ 令\\; x=atant, \\quad dx=a\\;(sect)^2 \\; dt \\\\ =\\int \\dfrac{1}{asect} \\; a(sect)^2, dt \\\\ =\\int sect\\, dt \\\\ =ln|sect + tant| + C \\\\ 回代 \\; sect = \\dfrac{\\sqrt{x^2 + a^2}}{a} \\; tant=\\dfrac{x}{a} \\\\ =ln|x + \\sqrt{x^2 + a^2}| + C ∫x2+a2​1​dx令x=atant,dx=a(sect)2dt=∫asect1​a(sect)2,dt=∫sectdt=ln∣sect+tant∣+C回代sect=ax2+a2​​tant=ax​=ln∣x+x2+a2​∣+C ∫a2−x2 dx令 x=asintdx=acostdt=∫a2(cost)2 dt=a2∫cos2t+12 dt=a2(sin2t4+t2)+C回代 sin2t=2sintcost=2xa2−x2a2t=arcsinxa=a22arcsinxa+x2a2−x2+C\\int\\sqrt{a^2 - x^2}\\, dx \\\\ 令\\; x=asint \\quad dx=acostdt \\\\ =\\int a^2 (cost)^2\\, dt \\\\ =a^2 \\int \\dfrac{cos2t+1}{2}\\, dt \\\\ =a^2(\\dfrac{sin2t}{4}+\\dfrac{t}{2})+ C \\\\ 回代 \\; sin2t=2sintcost=\\dfrac{2x\\sqrt{a^2-x^2}}{a^2} \\quad t=arcsin\\dfrac{x}{a} \\\\ =\\dfrac{a^2}{2}arcsin\\dfrac{x}{a} + \\dfrac{x}{2}\\sqrt{a^2 - x^2} + C∫a2−x2​dx令x=asintdx=acostdt=∫a2(cost)2dt=a2∫2cos2t+1​dt=a2(4sin2t​+2t​)+C回代sin2t=2sintcost=a22xa2−x2​​t=arcsinax​=2a2​arcsinax​+2x​a2−x2​+C 8平方差∫1x2−a2 dx=∫1(x+a)(x−a) dx=12a[∫1x+a dx−∫1x−a dx]=12alnx+ax−a+C\\int \\dfrac{1}{x^2-a^2}\\, dx \\\\ =\\int \\dfrac{1}{(x+a)(x-a)}\\, dx \\\\ =\\dfrac{1}{2a}[\\int \\dfrac{1}{x+a}\\,dx - \\int \\dfrac{1}{x-a}\\, dx]\\\\ =\\dfrac{1}{2a}ln\\dfrac{x+a}{x-a} + C∫x2−a21​dx=∫(x+a)(x−a)1​dx=2a1​[∫x+a1​dx−∫x−a1​dx]=2a1​lnx−ax+a​+C 9三角函数变换∫(cosx)2 dx=∫cos2x+12 dx=sin2x4+x2+C\\int (cosx)^2\\, dx=\\int \\dfrac{cos2x+1}{2}\\,dx=\\dfrac{sin2x}{4}+\\dfrac{x}{2}+ C∫(cosx)2dx=∫2cos2x+1​dx=4sin2x​+2x​+C∫(sinx)2 dx=∫1−cos2x2 dx=x2−sin2x4+C\\int (sinx)^2\\, dx=\\int \\dfrac{1-cos2x}{2}\\, dx=\\dfrac{x}{2} - \\dfrac{sin2x}{4} + C∫(sinx)2dx=∫21−cos2x​dx=2x​−4sin2x​+C∫(tanx)2 dx=∫(secx)2−1 dx=tanx−x+C\\int (tanx)^2\\, dx=\\int (secx)^2 - 1\\, dx=tanx - x + C∫(tanx)2dx=∫(secx)2−1dx=tanx−x+C∫(cotx)2 dx=∫(cscx)2−1 dx=−cotx−x+C\\int (cotx)^2\\, dx=\\int (cscx)^2 - 1\\, dx=-cotx - x + C∫(cotx)2dx=∫(cscx)2−1dx=−cotx−x+C","categories":[{"name":"考研","slug":"考研","permalink":"https://zzt.github.io/categories/%E8%80%83%E7%A0%94/"}],"tags":[{"name":"高数","slug":"高数","permalink":"https://zzt.github.io/tags/%E9%AB%98%E6%95%B0/"}]},{"title":"线性表","slug":"linear-list","date":"2022-01-26T14:35:02.000Z","updated":"2022-05-03T07:58:04.867Z","comments":true,"path":"2022/01/26/linear-list/","link":"","permalink":"https://zzt.github.io/2022/01/26/linear-list/","excerpt":"","text":"线性表的定义线性表是具有相同数据类型的 n (n&gt;=0) 个数据元素的有限序列。若用 L 命名线性表，则其一般表示为 $L=(a_1, a_2, … ,a_i ,a_{i+1}, …, a_n)$ 线性表的基本操作 InitList(&amp;n); 初始化表，构造一个空的线性表 Length(L); 获得线性表 L 的长度 LocateElem(L, e); 按值查找，在表 L 中找到数据元素 e GetElem(L, i); 按位查找，获取表 L 的第 i 个数据元素 ListInsert(&amp;L, i, e); 插入，向表 L 的 i 位置插入数据元素 e ListDelete(&amp;L, i, &amp;e); 删除，删除表 L 中 i 位置的元素，并将删除的值保存在 e 中 PrintList(L); 输出，按前后顺序输出表 L 中的数据元素 DestroyList(&amp;L); 销毁，销毁线性表 L，并释放 L 所占用的内存空间 顺序表的定义线性表的顺序存储称为顺序表。 重点 线性表中元素的序位是从 1 开始的，数组元素的下标是从 0 开始的 顺序表需要分配连续的内存空间，动态分配时，一旦空间沾满，就另外开辟一块更大的连续空间，用来替换原来的存储空间。比如，原表长 n，现已经存满，需要再扩充 m 个单位，则需要开辟连续的 m + n 空间，然后将原来的 n 个元素复制到新申请的空间中 综合题 从顺序表中删除具有最小值的元素（假设唯一）并由函数返回被删元素的值。空出的位置由最后一个元素填补，若顺序表为空则显示出错信息并退出运行。 12345678910111213141516bool Del_Min(sqList &amp;L, ElementType &amp;e) &#123; if (L.length == 0) &#123; return false; &#125; int index = 0; int min = L.data[0]; for(int i = 1; i &lt; L.length; i++) &#123; if (L.data[i] &lt; min) &#123; index = i; e = min; &#125; &#125; L.data[index] = L.data[L.length - 1]; L.length --;&#125; 设计一个高效算法，将顺序表 L 的所有元素逆置，要求空间复杂度为 O(1) 1234567891011void Reverse(sqList &amp;L) &#123; int head = 0; int tail = L.length - 1; while (head &lt; tail) &#123; int temp = L.data[head]; L.data[head] = L.data[tail]; L.data[tail] = temp; head ++; tail --; &#125;&#125;","categories":[{"name":"考研","slug":"考研","permalink":"https://zzt.github.io/categories/%E8%80%83%E7%A0%94/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://zzt.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}]},{"title":"音频开发基础","slug":"audio-basic","date":"2022-01-22T17:53:41.000Z","updated":"2022-01-22T17:57:55.184Z","comments":true,"path":"2022/01/23/audio-basic/","link":"","permalink":"https://zzt.github.io/2022/01/23/audio-basic/","excerpt":"","text":"本人目前音视频技术基本零基础（在公司里耳濡目染，听过一些概念，有着肤浅的理解，实际是一头雾水），鉴于本人在短视频公司工作过（不好意思不懂这些），本身其实对这块也比较感兴趣，加上之前一直没下决心系统学习这块知识，现在想开始从零开始系统学习音视频技术，并记录学习笔记「音视频从零开始」系列，希望能帮到更多零基础想学习音视频技术的同学 注：系列文章都是通过查找各个资料加上我个人理解总结出来的学习笔记，文章最后会附上参考文章或书籍的连接，如果有理解不对或有涉及知识侵权的地方，请及时评论联系我 这是音视频技术从零开始学习笔记的第一篇，从音频技术相关的概念开始，本篇不涉及任何编程相关内容。个人认为，概念理解清楚对以后编程模块的边界、职责划分以及该使用哪些工具有很大的帮助。 图1-音频技术核心概念 采样模拟信号（连续信号）是连续的，意味着不会失真（音质好），比如磁带、唱片中就通过物理介质（通过唱片表面的起伏跌宕，或者是磁带上的磁粉引起的磁场强度来表示音箱上振膜的即时位置）保存着音频的模拟信号。 我们都知道唱片和磁带已经逐渐离开人们的视野，就是因为通过物理手段无法长久的保存音频信号，唱片会磨损，磁带会老化，那用什么方法能够长久的保存音频信息呢？ 目前，使用最多的方法就是通过数字来保存音频，那么又如何将音频转为数字呢？首先先通过图中「采样」手段，将模拟信号转为离散信号，离散信号可以理解为不连续信号，把一段连续函数按照一定规则断开。 图2-采样信号 原图链接 此图为CD标准的采样信号图，图中的「采样率44.1Khz」就是断开函数的规则，每 1s 将一段波分为 44100 个矩形，经过采样，得到了一个有一堆柱形图组成的图形（离散信号） 为什么音频的采样率是 44.1Khz 呢？对于高质量的音频（人耳能够听到的频率范围是 20hz-20Khz），根据采样定理，按比人能听到的最大频率的2倍进行采样可以保证声音在被数字化处理后，还能有质量保障 量化图3-量化（信号处理） 经过采样后，我们发现图中的纵坐标是没有值的，无法表示每段样本的数字大小，这时候就需要引入量化的概念。通俗易懂地讲「量化」就是在沿垂直方向再将信号图按照一定数字范围切断，保证每段样本能用数字描述。这个数字的最终物理意义是反应在音响振膜位置，比如用[0-10万]进行量化，最终反应在振膜的位置就是 0-10万。 那么CD的量化标准是什么呢？采用16bit(short)，也就是2的16次方，总共65536，然后为了由于振膜是可以发生正向和负向位移，所以用[-32767,32768]进行量化。 所以图中虚线范围就代表了量化的数字范围，最终的红色曲线就是量化的结果，数字信号 编码经过量化后，每一个采样都是一个数字，那这么多的数字该如何存储呢？这就需要第三个概念：「编码」，所谓编码，就是按照一定的格式记录采样和量化后的数据，比如顺序存储或压缩存储等。 这里涉及很多种格式，通常所说的音频的裸数据格式就是脉冲编码调制数据，简称 PCM （Pulse Code Modulation)。描述一段 PCM 通常需要以下三个概念 量化格式（SampleFormat） 采样率（SampleRate) 声道数（Channel) 还以CD标准为例，量化格式 16bit，采样率 44100，声道数 2。 这里对声道概念做一个补充，平时所谓的双声道、单声道其实可以理解为需要记录几个信号，比如磁带，双声道就是同一时刻记录两个轨道的信息，一个负责记录左耳机振膜位置，一个负责记录右耳机振膜位置，以此类推，多个声道也是类似 上述信息就描述了CD的音质，对于声音格式来说，还有另一个概念用来描述它的大小，称为数据比特率（bitRate)，即 1s 内的比特数目，用于衡量音频数据单位时间内的容量大小，那么比特率如何计算？ $BitRate=SampleFormatSampleRateChannel $单位为千比特每秒kbps(kb per second)。比如对于CD音质，$44100162=1378.125kbps$那么，一分钟里，CD音质数据需要占多大存储空间呢？$1378.125*60/8/1024=10.09MB$ 所以一段1分钟的音频经过采样、量化、编码后可以得到一个大约10MB裸数据，成功地将音频的模拟信号转为数字信号，并存储下来。 音频压缩编码上面说到1分钟的CD音质数据的存储空间大于为 10MB，这对于光盘磁盘存储来说可接受，但对于网络传输肯定是无法接受的。所以就需要「压缩编码」出面解决问题 所谓音频编码主要指音频压缩技术，压缩通常又被分为有损和无损两种，但事实上，任何音频编码方式相对于最真实的自然声音信号，都是有损的压缩。从前面说到的采样、量化、编码中不难理解，我们把一条光滑的音频信号曲线分割成了许多数据块，然后对数据进行二进制编码，过程中其实就已经损失了一部分数据了，所以再次进行压缩也只能是尽可能的接近经过PCM编码后的音频裸数据。 图4-PCM编码 原图链接 既然压缩是为了减小编码后的数据存储空间，那么就应该去掉音频的“冗余信息”，从以下两个方面去衡量哪些数据是冗余的 之前提到过，人耳所能察觉的声音信号的频率范围为20Hz-20KHz，除此之外的其它频率人耳无法察觉，都可视为冗余信号 当一个强音频信号和一个弱音频信号同时存在时，弱信号会被强信号掩蔽，可视为冗余 其中第二点涉及另两个概念「频谱掩蔽效应」和「时域掩蔽效应」，名字看起来高深莫测，其实不难理解。 图5-频谱掩蔽效应 原图链接 「频谱掩蔽效应」一个音频信号被人耳听到是有一个阈值，阈值越小越容易被人听到，如图所示，虚线是随声音频率增大反应的阈值曲线，在 2-5kHz范围内，阈值很低，是人耳对声音最敏感的频率。现在假设有一个 60dB-0.2kHz 的强音信号出现时，阈值曲线会有所改变（图中实线部分），0.1-0.5kHz 频率的阈值被明显抬高，图中大概40dB-0.17kHz 左右的信号和 30dB-0.48kHz左右的信号都会被掩蔽。所以在0.1kHz-0.5kHz范围内，只能听到 65dp-0.2kHz 的声音，其余信号可视为冗余。 图6-时域掩蔽效应 原图链接 「时域掩蔽效应」是强信号和弱信号在时间维度发生的掩蔽，分为 前掩蔽，人在听到强信号之前，一些弱信号会被掩蔽 同时掩蔽，强信号会掩蔽同时发生的弱信号 后掩蔽，强信号消失后，需要经过一段时间后，才能重新听到弱信号 在这过程中被掩蔽的信号被视为冗余 几种音频压缩编码简介 编码 实现简介 特点 适用场景 WAV 无损压缩，其中一种实现方式是在 PCM 数据格式前加上 44 字节，分别描述采样率、声道数、数据格式等信息。 音质非常好，大量软件都支持 多媒体开发的中间文件、保存音乐和音效 MP3 具有不错的压缩比，使用 LAME 编码（MP3 编码格式的一种实现）的中高码率的 MP3 文件 音质在 128Kbit/s 以上表现还不错，压缩比比较高，大量软硬件都支持 高比特率下对兼容性有要求的音乐鉴赏 AAC 新一代有损压缩技术，通过一些附加的编码技术（PS、SBR 等），衍生出了 LC-AAC、HE-AAC、HE-AAC v2三种主要编码格式 小于 128Kbit/s 表现优异，多用于视频中的音频编码 128Kbit/s 一下的音频编码，多用于视频中的音频编码 Ogg 一种非常有潜力的编码，各种码率下都有比较优秀的表现，尤其是低码率场景下。可以在低码率的场景下仍然保持不错的音质，但目前软件硬件支持情况较差 可用比 MP3 更小的码率实现比 MP3 更好的音质，但兼容性不好 语音聊天的音频消息场景 1.压缩比，压缩后大小/原大小，通常小于 1，越小表示压缩的越狠2.“码率”是比特率是俗称3.表格总结于《音视频开发指南》，其中一些细节有兴趣的同学可以再深入查阅，本文不再深入研究 思考 为什么磁带、唱片逐渐消失在人们的视野里，音频播放器可以取而代之？ 声音是经过怎样的处理过程后保存成数字信息的？ 为什么要对音频数据进行压缩编码？ 参考链接 将模拟音频向数字音频的转换过程是怎样的？ 量化 (信号处理)) 雷骁骅-视频压缩编码和音频压缩编码的基本原理 雷骁骅-视音频编解码技术零基础学习方法 百度百科-PCM 编码 百度百科-音频编码 《音视频开发进阶指南-基于 Android 和 iOS 平台的实践》 - 第1章 音视频基础概念 转文声明如有文章转载需求，请注明本文作者以及链接，感谢各位理解支持","categories":[{"name":"Video","slug":"Video","permalink":"https://zzt.github.io/categories/Video/"}],"tags":[]},{"title":"初识比特币","slug":"bc-bitcoin-concept","date":"2022-01-22T17:01:56.000Z","updated":"2022-01-22T17:06:12.356Z","comments":true,"path":"2022/01/23/bc-bitcoin-concept/","link":"","permalink":"https://zzt.github.io/2022/01/23/bc-bitcoin-concept/","excerpt":"","text":"什么是比特币？ A purely peer-to-peer version of electronic cash would allow online payments to be sent directly from one party to another without going through a financial institution. 一个纯正的点对点去中心化的加密数字货币，应能够通过在线支付将币从一方直接发送到另一方，而无需通过任何中心金融机构。 比特币是一种加密货币（crypto-currency），实现自一个自称中本聪（Satoshi Nakamoto）的不明身份的人所发表的一篇论文（比特币白皮书） 与其说比特币是一种加密货币，不如说比特币是一种基于 P2P 网络的支付结算系统，这样更易于大家理解其本质。 为什么要发明比特币？中心化，基于信任模型 酒花 App 平台买了两瓶精酿啤酒一个自称三方供应商的人加我微信，告知我其中一瓶酒没货了，可以加钱换其他的酒虽然这个人微信朋友圈都是精酿啤酒相关的内容，且明确知道我买的哪个酒没货了但是，我内心还是不信任这个人，更信任平台，于是我还是在平台换了一瓶酒 平台就真的值得信任么？假如我下单的时候正好赶上平台服务器宕机，扣款成功了，但没收到货。由于平台系统做的不好，再也找不到那笔订单，不能证明我付过钱，也不能给我发货。这笔交易就没有人能说的清楚了，信任也就不存在了。 比特币要去解决信任问题 What is needed is an electronic payment system based on cryptographic proof instead of trust, allowing any two willing parties to transact directly with each other without the need for a trusted third party. 我们真正需要的是一种基于加密算法密码学原理而非基于信任的数字货币支付系统，不需要可信任第三方参与的情况下，允许双方直接进行支付交易 双花攻击（Double Spending Attack)「双花」即同一笔钱花了两次或多次。 假设央行发行了一款数字货币，货币在软件中其实就是文件，完全可以复制。假如 A 在转给 B 100 元后，又复制了同一笔钱转给了 C，就是所谓的「双花」，双花攻击只通过验证数字货币的签名是不够的，还需要使用额外的手段。 比特币要去解决双花问题 We propose a solution to the double-spending problem using a peer-to-peer network 我们将在本文提出一种新方案，使用点对点去中心化网络去解决这个双花问题 在比特币交易小节中，会详细解释比特币是如何解决双花问题的。 比特币中的密码学哈希算法（Hash Algorithm)哈希算法是用来做什么的呢？我们先来看一个小故事。 雍正到底是不是篡位登基的？ 一直有一个传说称雍正不是康熙真正传位的皇帝，而是有人偷偷修改了遗诏，篡位登基的。 假如康熙知道哈希函数 如果没有哈希函数，在康熙皇帝驾崩后，遗诏是死无对证，只能遗诏写什么，大臣就做什么。 但有了哈希函数后就变得不一样了，康熙可以在活着的时候就可以提前写好遗诏，并用哈希函数计算出一个哈希串，交予大臣们。大臣们看到哈希串也不能猜出遗诏的内容到底是什么，只能等到遗诏公布的那天，再去计算一次哈希值，看与当初皇帝给的哈希串是否一致，来判断遗诏是否被人篡改了。如果修改了，就不会遵诏行事。 通过这个小故事，可以简单总结出哈希的两个性质： 防篡改，输入稍有改动，输出千差万别 输出结果不可逆，只知道结果不能反推出输入是什么 比特币使用的哈希算法SHA256（Security Hash Algorithm），是一种密码哈希函数（Cryptographic Hash Function）。 $任意输入 ==&gt; SHA256 ==&gt; 256位哈希$ 在比特币中，利用了SHA256的三个性质 不可逆（Hiding） 抗哈希碰撞（Collision .istance） 哈希值不可预测（Puzzle friendly） 不可逆（Hiding）SHA256的特性： 输入长度任意 输出长度固定，256bit 比如 $全世界的图书 ==&gt; SHA256 ==&gt; 256 位哈希$ 如果这个过程可逆的话，我们就发现了一种无敌的压缩算法，可以把全世界的图书压成 256 位，再进行存储。 抗哈希碰撞（Collision .istance）根据抽屉原理，输入空间无限，输出空间有限，理论上一定会存在碰撞。 但是，从长期经验看，没有什么人为的、高效的方式制造碰撞。 只能通过暴力遍历输入空间的方式来寻找碰撞 哈希值不可预测（Puzzle friendly）Puzzle Friendly，直译为谜题友好性，是指事先给定一个哈希串，比如 00000000feacb46d… ，前 8 位都是 0，让你解谜题找到输入是什么。 由于 SHA256 没有直接办法或通过找到一定规律来猜出输入是什么，只能通过暴力遍历输入空间的方式来找到答案。（其实一点都不友好） 比如你找到一个输入 a，输出的前 7 位都是 0，感觉再简单调整一下输入就能找到答案了，其实不是的，修改输入后可能得到的答案一个 0 都没有。也就是说你的每一次计算是无记忆性的（Memoryless），只能通过大量地尝试，不断的寻找答案。 除此之外，找到答案后，其他人验证答案却很简单，只需要把你的答案再用哈希函数计算一次即可。（difficult to solve, but easy to verify） 比特币挖矿过程充分利用了 Puzzle friendly，后面我们会详细说明。 数字签名（Digital Signature）了解数字签名之前，需要先对非对称加密有一定认识。 什么是非对称加密？ Alice 想通过非对称加密的方式发送一条消息给 Bob，他要怎么做呢？ Bob 需要先生成公钥私钥对（public key, private key） Bob 的公钥是对所有人公开的，所以 Alice 可以拿到 Bob’s public key Alice 使用 Bob’s public key 对 Message 加密，并将密文通过网络传输给 Bob Bob 接收到密文后，使用自己的私钥 Bob’s private key 解密，得到了 Message 完成通信 由于 Bob’s private key 是保存在 Bob 手里的，只要私钥不泄露，就是安全的。 3.3.2、什么是数字签名？还是 Alice 想要给 Bob 发送一条消息，并采用非对称加密的方式，Alice 凭什么相信 Bob 的公钥就是 Bob 的呢？有没有可能被其他人调包了呢？这就需要 Alice 用到数字签名的技术，来验证 Bob 的身份是否真实 Bob 用私钥生成数字签名 Alice 用 Bob 的公钥验证签名 如果验证通过，则证明公钥一定是 Bob 的，因为签名只能由 Bob 的私钥生成 四、比特币是如何交易的？4.1、区块链在比特币系统中，交易是存在区块里的，那么区块链到底是什么呢？ 一个区块是由 block header 和 block body 组成 block header 中会存储前一个区块头的哈希值 block body 中会存储具体的交易信息（Transaction 简写为 Tx) 区块链其实不是区块组成的链表结构，而是通过 (key,value) 数据库实现的。在数据库中，key 是区块头的哈希值，value 是区块内容。 账户在比特币中，账户就是由本机生成的公私钥对 公钥的哈希值用作转账地址，相当于银行卡号 私钥相当于银行密码，需要自己妥善保管，一旦丢失是无法找回的 防止双花现实中，A -&gt; B 100元人民币的过程实际是 A 的钱包减少 100元，B 的钱包增加 100元，天然能防止「双花」（除非你把花出去的钱偷回来再花一次）。 但是，比特币中没有账户系统，不会帮你记录用户的账户中余额还有多少。那么，比特币是如何验证「双花」的呢？ 回溯币源比特币的每笔交易由未花费的输出（UTXO Unspenting Transaction Output），本次交易的输入拼接而成。每笔交易会去验证 UTXO 是否能支付足量的币，具体可以看下面的例子。 coinbase 称作「铸币」交易，是矿工挖出新区块获得的出块奖励，假设是 A 获得了出块奖励的 10 BTC A 转给了 B 5 BTC，同时转给了 C 5 BTC，这时系统会去验证 A 有没有能力支付 10 BTC，会向前回溯找到 A BTC 的来源，于是找到了铸币交易，发现有 10 BTC，交易合法 同理 C 在转给 E 7BTC 时，需要找到之前交易中得到的 5 + 2 BTC 转账者除了要证明币源，还需要将交易用自己的私钥签名，用于身份验证。 比特币挖矿为什么要挖矿？ 产生比特币，只有挖出新的区块，才会产生新的比特币。中本聪规定，最初出块奖励为 50 BTC，每隔 4 年出块奖励减半，所以比特币总量大概为 2100 万个 打包交易，通过挖出新区块，打包记录新产生的交易 达成共识，通过工作量证明（Proof of Work）+ 奖励机制，让系统中的节点达成共识，向好的方向发展 挖矿的过程 比特币挖矿的过程和实际挖金矿的过程很像： 金子的总量是有限的，越挖会越少，比特币也是如此 挖金子需要付出科技成本和体力劳动后才能得到回报，比特币也是需要付出算力、电力成本，才能收获比特币 下面我们来简单了解一下，比特币挖矿的过程是怎样的。 找到最长合法链在比特币中的矿工指的是系统中的全节点，除了挖矿，还要负责维护全量的区块数据 诚实的矿工会按照最长合法链规则挖矿 最长，顾名思义，矿工只沿着系统中最长的链向后挖 合法，验证区块信息是否被篡改，区块中记录的所有的交易是否合法。一旦矿工识别当前链不合规，便会马上找到另外的最长合法链，继续挖矿 挖矿解谜简单说，挖矿解谜就是矿工通过暴力哈希运算，找到符合要求的随机数 nonce，满足下面的公式 $H(header || nonce) &lt;= target$ target 是一串 256 位的哈希（前 k 位都是 0） k 越大，target 越小，挖矿难度越高。就像打靶子一样，k 越大，表示靶子越小，越难命中 增加算力，会增加挖到矿的概率，但不代表当前区块一定会被算力高的矿工挖到 中本聪设计出块时间在10分钟左右，每两周调整一次挖矿难度。比如上两周平均出块时间为 7 分钟，则会增大难度，否则会降低难度。 广播解谜成功后，需要迅速把组装好的区块向相邻节点广播，让自己挖的区块在最长合法链中得到确认，拿到出块奖励和交易手续费。 6次交易确认机制 网络是不可靠的，在广播阶段很有可能出现延时。所以交易上链后，并不是马上就生效的，中本聪设计了一个区块上链后需要再等 6 个区块上链后才能被真正确认。 为什么要这样做？ 防止双花，假如甲、乙矿工同时挖到了新区块，并且广播了出去。其中甲记录 A 转给 B 10BTC，乙记录了 A 转给 C 10BTC，事实上 A 只有 10BTC，如果两个区块都被认可，那就出现了双花。 为什么是 6 次？中本聪认为，6 个区块大概要花费一个小时才能挖出来，想要再做一次分叉攻击篡改，是需要较大成本的。 51%算力攻击 假设有某个组织拥有了全世界 51% 的算力，并且一直在沿着自己的链挖矿，理论上某个时间点，这个组织所挖的链就会变成最长的，广播后，这条链就会成为最长合法链，那么以前的交易就会被这个组织替换。 51% 攻击只能将合法的交易替换上链，但是无法偷其他用户的比特币，因为诚实的节点会验证交易的签名。 51% 攻击是可以发动双花攻击的，由于算力强大，会导致 6 次确认机制失效。比如 A =&gt; B (10BTC) 已经得到确认，其中 A 是攻击者，交易是 A 的签名，发动 51% 攻击后，完全可以修改为 A =&gt; C (10BTC)，C 可以是攻击者的另一个账户。 51% 只是一个象征性的数字，并不一定算力一定要达到 51 才能攻击，有研究小组表明只要拥有 30% 的全网算力，就足以发动 51% 攻击。（为什么只需要30%？个人猜测是，其他算力之间还存在竞争关系，而这30%是团结一致的） 曾有矿池（GHash.IO）算力超过了 51%，一度引起比特币价值暴跌，之后很多矿工自觉退出了矿池，来保证系统的安全。 比特币系统在「安全性」「高价值」「健康挖矿」三个方面已经形成闭环。算力越高，想发动 51% 攻击就越困难，系统就越安全，随之比特币价格就会越高。使得想要发动攻击的人即使发动了攻击也不一定能赚到什么，还不如用所有算力稳稳挖矿收益高。 比特币的缺点 工作量证明机制造成算力、电力的浪费 出块时间限定平均10分钟左右，一笔交易需要大概需要1小时才能得被系统确认 比特币私钥丢失之后，是没办法找回的，账户中的比特币永远都取不出来了 转账写错地址，无法回滚 参考 《零基础学区块链》 北京大学肖臻老师的公开课 比特币白皮书 《图说区块链》 《图解密码技术》","categories":[{"name":"BlockChain","slug":"BlockChain","permalink":"https://zzt.github.io/categories/BlockChain/"}],"tags":[]},{"title":"Kotlin 协程的创建过程","slug":"kt-coroutine-create","date":"2022-01-22T16:55:34.000Z","updated":"2022-01-22T17:12:12.542Z","comments":true,"path":"2022/01/23/kt-coroutine-create/","link":"","permalink":"https://zzt.github.io/2022/01/23/kt-coroutine-create/","excerpt":"","text":"创建并启动协程123456789101112131415161718fun create.main() &#123; //1. 创建协程体 val coroutine = suspend &#123; println(&quot;in coroutine&quot;) 5 &#125;.createCoroutine(object: Continuation&lt;Int&gt; &#123; override fun resumeWith(result: Result&lt;Int&gt;) &#123; println(&quot;coroutine end: $result&quot;) &#125; override val context: CoroutineContext get() = EmptyCoroutineContext &#125;) //2. 执行协程 coroutine.resume(Unit)&#125; 上面代码的输出结果：12in coroutinecoroutine end: Success(5) 协程的执行过程 调用栈流程如下 我们通过 suspend block#createCoroutine 得到的 coroutine 实际是 SafeContinuation 对象 SafeContinuation 实际上是代理类，其中的 delegate 属性才是真正的 Continuation 对象 suspend block 中的代码在 BaseContinuationImpl 中执行 我们的匿名内部类对象 Continuation 被回调 suspend block 是如何变为协程体被执行的？我们分析调用栈得知，resumeWith 最终是在 BaseContinuationImpl 中执行的，下面来看看代码 123456789101112131415161718192021222324252627282930313233@SinceKotlin(&quot;1.3&quot;)internal abstract class BaseContinuationImpl( public val completion: Continuation&lt;Any?&gt;?) : Continuation&lt;Any?&gt;, CoroutineStackFrame, Serializable &#123; public final override fun resumeWith(result: Result&lt;Any?&gt;) &#123; var current = this var param = result while (true) &#123; probeCoroutineResumed(current) with(current) &#123; val completion = completion!! val outcome: Result&lt;Any?&gt; = try &#123; val outcome = invokeSuspend(param) //1.这里执行了 suspend block if (outcome === COROUTINE_SUSPENDED) return Result.success(outcome) &#125; catch (exception: Throwable) &#123; Result.failure(exception) &#125; releaseIntercepted() if (completion is BaseContinuationImpl) &#123; current = completion param = outcome &#125; else &#123; completion.resumeWith(outcome) //2.这里回调了我们的匿名内部类 return &#125; &#125; &#125; &#125; protected abstract fun invokeSuspend(result: Result&lt;Any?&gt;): Any? //3. 抽象方法&#125; 在代码注释 1. 处，调用 current.invokeSuspend，执行了我们定义的协程体，证明 suspend block 其实是 BaseContinuationImpl 的子类 在 2. 处，协程体执行完毕后，我们的代码收到了完成回调 在 3. 处，可以发现 invokeSuspend 是个抽象方法，suspend block 就是这个方法的具体实现 下面我通过断点，进一步分析 suspend block 是通过哪个子类执行的。 可以看到 current 是名为 {文件}${方法}${变量}$1 格式的对象，证明 kotlin 编译器遇到 suspend 关键字后会帮我们生成一个 BaseContinuationImpl 的子类 那么，这个子类到底是什么呢？将 kt 编译为 .class 再通过 jadx 打开后，得到的 java 代码如下 12345678public final class CreateCoroutineKt &#123; public static final void create.main() &#123; Continuation coroutine = ContinuationKt.createCoroutine(new CreateCoroutineKt$create.main$coroutine$1(null), new CreateCoroutineKt$create.main$coroutine$2()); Unit unit = Unit.INSTANCE; Result.Companion companion = Result.Companion; coroutine.resumeWith(Result.constructor-impl(unit)); &#125;&#125; 123456789101112131415161718192021222324252627282930final class CreateCoroutineKt$create.main$coroutine$1 extends SuspendLambda implements Function1&lt;Continuation&lt;? super Integer&gt;, Object&gt; &#123; int label; CreateCoroutineKt$create.main$coroutine$1(Continuation&lt;? super CreateCoroutineKt$create.main$coroutine$1&gt; continuation) &#123; super(1, continuation); &#125; @NotNull public final Continuation&lt;Unit&gt; create(@NotNull Continuation&lt;?&gt; continuation) &#123; return new CreateCoroutineKt$create.main$coroutine$1(continuation); &#125; @Nullable public final Object invoke(@Nullable Continuation&lt;? super Integer&gt; continuation) &#123; return create(continuation).invokeSuspend(Unit.INSTANCE); &#125; @Nullable public final Object invokeSuspend(@NotNull Object obj) &#123; IntrinsicsKt.getCOROUTINE_SUSPENDED(); switch (this.label) &#123; case 0: ResultKt.throwOnFailure(obj); System.out.println((Object) &quot;in coroutine&quot;); //协程体的逻辑 return Boxing.boxInt(5); default: throw new IllegalStateException(&quot;call to &#x27;resume&#x27; before &#x27;invoke&#x27; with coroutine&quot;); &#125; &#125;&#125; 明显看出，kt 编译器帮助我们把 suspend 关键字变为了 SuspendLambda 的 子类，并重写了 invokeSuspend 方法，不难猜出 SuspendLambda 继承自 BaseContinuationImp 总结用一个类图简单的总结一个协程创建并执行的过程。 suspend block(lambda) 在编译时会转变为 SuspendLambda 的匿名子类，并把 block 中的逻辑通过重写 invokeSuspend 实现 调用 suspend_lambda.createCoroutine 会得到 SafeContinuation 对象，这只是一个代理类，代理的对象正是我们传入的 SuspendLambda createCoroutine 的参数是 completion，代表协程执行完毕的回调 最终调用到了 BaseContinuationImpl 的 resumeWith，完成协程的调用，调用完毕的回调","categories":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://zzt.github.io/categories/Kotlin/"}],"tags":[{"name":"Kotlin协程","slug":"Kotlin协程","permalink":"https://zzt.github.io/tags/Kotlin%E5%8D%8F%E7%A8%8B/"}]},{"title":"Kotlin Sequence 原理","slug":"kt-sequence","date":"2022-01-22T14:01:56.000Z","updated":"2022-01-22T16:47:05.055Z","comments":true,"path":"2022/01/22/kt-sequence/","link":"","permalink":"https://zzt.github.io/2022/01/22/kt-sequence/","excerpt":"","text":"一、Sequence 和 List 的区别以下内容出自官方示例 1. List123456789fun list() &#123; val words = &quot;The quick brown fox jumps over the lazy dog&quot;.split(&quot; &quot;) val wordList = words.toList() val lengthList = wordList.filter&#123; println(&quot;filter $it&quot;); it.length &gt; 3&#125; .map &#123; println(&quot;map $&#123;it.length&#125;&quot;); it.length &#125; .take(4) println(&quot;Lengths of first 4 words longer than 3 chars&quot;) println(lengthList)&#125; 运行结果如下12345678910111213141516filter Thefilter quickfilter brownfilter foxfilter jumpsfilter overfilter thefilter lazyfilter dogmap 5map 5map 5map 4map 4Lengths of first 4 words longer than 3 chars[5, 5, 5, 4]运行过程 2. Sequence1234567891011121314151617fun sequence() &#123; val words = &quot;The quick brown fox jumps over the lazy dog&quot;.split(&quot; &quot;) val wordSeq = words.asSequence() val lengthSeq = wordSeq .filter &#123; println(&quot;filter $it&quot;) it.length &gt; 3 &#125; .map &#123; println(&quot;map $&#123;it.length&#125;&quot;) it.length &#125; .take(4) println(&quot;Lengths of first 4 words longer than 3 chars&quot;) println(lengthSeq.toList())&#125; 运行结果如下123456789101112Lengths of first 4 words longer than 3 charsfilter Thefilter quickmap 5filter brownmap 5filter foxfilter jumpsmap 5filter overmap 4[5, 5, 5, 4]运行过程 3. 区别 直观来看，sequence 执行的步骤少于 list list 的操作符会立即执行，sequence 的操作符可以理解为先声明，后面执行 toList 的时候才会触发 list filter 操作符处理了全量数据，然后 map 映射 filter 之后的所有数据，sequence 则是每条数据经过 filter -&gt; map 流水线处理，不合格的数据不会向后执行 二、Sequence 原理下面我们具体看看 为什么 sequence 能做到先声明，后触发 为什么 sequence 能实现流水线的效果，避免操作浪费 下面的图描述了，声明操作符到触发流程的过程，我们逐一剖析每一步都做了什么 我们按照代码真正执行的顺序来分析，有助于理解，执行顺序正和我们声明操作的顺序相反 take &amp; toList最后的操作符是 take(4)，然后将其转为了 List。首先来看看 take1234567891011121314151617181920212223242526272829303132333435363738//take(4) 操作符其实对应的会生成一个 TakeSequence 对象public fun &lt;T&gt; Sequence&lt;T&gt;.take(n: Int): Sequence&lt;T&gt; &#123; require(n &gt;= 0) &#123; &quot;Requested element count $n is less than zero.&quot; &#125; return when &#123; n == 0 -&gt; emptySequence() this is DropTakeSequence -&gt; this.take(n) else -&gt; TakeSequence(this, n) &#125;&#125;internal class TakeSequence&lt;T&gt;( private val sequence: Sequence&lt;T&gt;, //传入了上一个Sequence，也就是 map 对应的 Sequence private val count: Int) : Sequence&lt;T&gt;, DropTakeSequence&lt;T&gt; &#123; init &#123; require(count &gt;= 0) &#123; &quot;count must be non-negative, but was $count.&quot; &#125; &#125; override fun drop(n: Int): Sequence&lt;T&gt; = if (n &gt;= count) emptySequence() else SubSequence(sequence, n, count) override fun take(n: Int): Sequence&lt;T&gt; = if (n &gt;= count) this else TakeSequence(sequence, n) override fun iterator(): Iterator&lt;T&gt; = object : Iterator&lt;T&gt; &#123; var left = count val iterator = sequence.iterator() //map 对应的 Sequence 的 iterator override fun next(): T &#123; if (left == 0) throw NoSuchElementException() left-- return iterator.next() &#125; override fun hasNext(): Boolean &#123; //通过 left，决定取 list 中的前几个数据 return left &gt; 0 &amp;&amp; iterator.hasNext() //看上一个 iterator 中是否有数据 &#125; &#125;&#125;代码中的注释已经详细解释了逻辑，其中重点是： 操作符会对应一个 Sequence 对象去处理迭代逻辑 TakeSequence 在构造的时候，传入了上一个 Sequence 对象 TakeSequence 的 hasNext 返回什么取决于上一个 iterator 的 hasNext 下面来看看 toList 做了什么12345678910public fun &lt;T&gt; Sequence&lt;T&gt;.toList(): List&lt;T&gt; &#123; return this.toMutableList().optimizeReadOnlyList()&#125;public fun &lt;T, C : MutableCollection&lt;in T&gt;&gt; Sequence&lt;T&gt;.toCollection(destination: C): C &#123; for (item in this) &#123; destination.add(item) &#125; return destination&#125;optimizeReadOnlyList 只是做了一次类型转换，将 mutable 转为 immutable。toMutableList 最终会调用到 toCollection，这里面就正式开始了 iterator 的逻辑，也就是走到了 TakeSequence 里面的迭代逻辑。 从 TakeSequence 迭代逻辑里知道，它会继续调用上一个 Sequence 的迭代器逻辑，所以，我们大致能猜出，Sequence 是通过类似责任链的方式，完成了流水线操作，我们继续分析。 map123456789101112131415161718192021222324public fun &lt;T, R&gt; Sequence&lt;T&gt;.map(transform: (T) -&gt; R): Sequence&lt;R&gt; &#123; return TransformingSequence(this, transform)&#125;internal class TransformingSequence&lt;T, R&gt;constructor( private val sequence: Sequence&lt;T&gt;, //传入了上一个 Sequence，filter 对应的 Sequence private val transformer: (T) -&gt; R) : Sequence&lt;R&gt; &#123; override fun iterator(): Iterator&lt;R&gt; = object : Iterator&lt;R&gt; &#123; val iterator = sequence.iterator() override fun next(): R &#123; return transformer(iterator.next())//这里调用我们的 map 逻辑 &#125; override fun hasNext(): Boolean &#123; return iterator.hasNext() //调用了上一个 iterator 的 hasNext &#125; &#125; internal fun &lt;E&gt; flatten(iterator: (R) -&gt; Iterator&lt;E&gt;): Sequence&lt;E&gt; &#123; return FlatteningSequence&lt;T, R, E&gt;(sequence, transformer, iterator) &#125;&#125; 果不其然，map 对应的 Sequence 是 TransformingSequence，并且迭代过程仍然会先调用上一个 Sequence 的 iterator，这基本印证了我们的猜想，继续分析。 filter123456789101112131415161718192021222324252627282930313233343536373839404142434445public fun &lt;T&gt; Sequence&lt;T&gt;.filter(predicate: (T) -&gt; Boolean): Sequence&lt;T&gt; &#123; return FilteringSequence(this, true, predicate)&#125;internal class FilteringSequence&lt;T&gt;( private val sequence: Sequence&lt;T&gt;,//传入上一个 Sequence，asSequence private val sendWhen: Boolean = true, private val predicate: (T) -&gt; Boolean) : Sequence&lt;T&gt; &#123; override fun iterator(): Iterator&lt;T&gt; = object : Iterator&lt;T&gt; &#123; val iterator = sequence.iterator() //上一个 Sequence 的 iterator var nextState: Int = -1 var nextItem: T? = null private fun calcNext() &#123; while (iterator.hasNext()) &#123;//上一个 iterator 是否有数据 val item = iterator.next() if (predicate(item) == sendWhen) &#123;//这里调用了我们的过滤逻辑 nextItem = item nextState = 1 return &#125; &#125; nextState = 0 &#125; override fun next(): T &#123; if (nextState == -1) calcNext() if (nextState == 0) throw NoSuchElementException() val result = nextItem nextItem = null nextState = -1 @Suppress(&quot;UNCHECKED_CAST&quot;) return result as T &#125; override fun hasNext(): Boolean &#123; if (nextState == -1) calcNext() return nextState == 1 &#125; &#125;&#125; 除了过滤逻辑和 map 不一致，其他是一样的。 asSequence12345678public fun &lt;T&gt; Iterable&lt;T&gt;.asSequence(): Sequence&lt;T&gt; &#123; return Sequence &#123; this.iterator() &#125;&#125;@kotlin.internal.InlineOnlypublic inline fun &lt;T&gt; Sequence(crossinline iterator: () -&gt; Iterator&lt;T&gt;): Sequence&lt;T&gt; = object : Sequence&lt;T&gt; &#123; override fun iterator(): Iterator&lt;T&gt; = iterator()&#125; 源码比较简单，就是 new 了一个 Sequence 的匿名对象，并且将 list 的 iterator 作为参数传了进去。所以，流水线最后调用的是 list 的 iterator。 三、总结 再看开始的流程图，回答提出的两个问题 1.为什么 sequence 能做到先声明，后触发因为操作符并不会触发迭代逻辑，只有最后的 toList 才会真正触发 2.为什么 sequence 能实现流水线的效果，避免操作浪费因为我们在声明操作符的时候，将 Sequence 对象组装了成了一个链，迭代的时候会从最后一个声明的 iterator 递归地调到第一个声明的 iterator，保证执行顺序是我们声明的顺序。并且，如果迭代的某一环不满足条件，就不会继续走到下一个迭代里，也就避免了操作的浪费。 如需转载，请注明原文出处，谢谢！","categories":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://zzt.github.io/categories/Kotlin/"}],"tags":[{"name":"Kotlin基础","slug":"Kotlin基础","permalink":"https://zzt.github.io/tags/Kotlin%E5%9F%BA%E7%A1%80/"}]},{"title":"Kotlin Lambda 函数中的 Receiver 是什么？","slug":"kt-receiver","date":"2022-01-22T13:31:48.000Z","updated":"2022-01-22T16:47:10.945Z","comments":true,"path":"2022/01/22/kt-receiver/","link":"","permalink":"https://zzt.github.io/2022/01/22/kt-receiver/","excerpt":"","text":"一、示例代码先来看一段示例代码，初步了解 Receiver 是什么 123456789101112131415import java.lang.StringBuilderfun main() &#123; println(&quot;&quot;.buildString &#123; this.append(&quot;a&quot;) append(&quot;b&quot;) append(&quot;c&quot;) &#125;)&#125;fun String.buildString(action: StringBuilder.() -&gt; Unit): String &#123; val sb = StringBuilder() sb.action() return sb.toString()&#125; 上述代码可以为 String 增加一个扩展函数 buildString，可以直接在 buildString {} 作用域中使用 StringBuilder 的 append 或其他方法，省去了我们自己 new StringBuilder 的过程 下面是对代码的详细解释 形如 T.() -&gt; R 的函数，就是 Receiver 类型 需要通过调用 [T的对象].() 的方式，来把 [T的对象] 作为 this 传到 lambda 作用域中 调用扩展函数时，可以显式用 this 访问传进来的对象 也可隐式调用 二、上述代码翻译成 java 是什么样的？通过 jadx 工具将 class 转为 java后，代码如下 main 方法中原本的 lambda 被转为了 buildString(&quot;&quot;, ReceiverKt$main$1.INSTANCE)，ReceiverKt$main$1 是什么我们稍后分析 buildString 方法接收了一个 Function1 类型的对象，证明 ReceiverKt$main$1 是 kt 帮我们生成的并且实现了 Function1 buildString 内部逻辑就是创建了一个 StringBuilder，然后调用 function1.invoke(sb) 下面来看看 ReceiverKt$main$1 是什么 很简单，就是通过 invoke 调用我们 buildString lambda 里的内容 三、另一个代码示例下面我们来看一段和上面例子很像的代码12345678910111213fun main() &#123; println(&quot;&quot;.buildString_ &#123;sb: StringBuilder -&gt; sb.append(&quot;d&quot;) sb.append(&quot;e&quot;) sb.append(&quot;f&quot;) &#125;)&#125;fun String.buildString_(action: (stringbuilder: StringBuilder) -&gt; Unit): String &#123; val sb = StringBuilder() action(sb) return sb.toString()&#125;和第一段代码的区别是 buildString 参数变为了 (StringBuilder) -&gt; Unit，我们将 StringBuilder 对象作为 lambda 的参数传入了 调用的地方需要使用 it 或者自己定义一个参数名来使用 StringBuilder 对象 这段代码转为 Java 后是什么样的呢？ 可以看到使用 Receiver 的方式和使用给 lambda 函数定义参数的方式转为 Java 代码后只是在 invoke 参数的变量名有区别，仅此而已。 四、小结 定义 lambda Receiver，调用方可以在 lambda 作用域中使用 this 访问 Receiver 对象 定义 lambda 带参函数，调用方可以在 lambda 作用域中自己定义对象变量名或者使用默认的 it 上述两种方式转为 Java 并没有什么本质区别，只是变量名上的不同 五、kotlin 标准库里的操作符哪些用到了 Receiver？在了解 Receiver 的原理后，可以让我们更好地理解 kotlin 标准库里的操作符 1.apply12345678@kotlin.internal.InlineOnlypublic inline fun &lt;T&gt; T.apply(block: T.() -&gt; Unit): T &#123; contract &#123; callsInPlace(block, InvocationKind.EXACTLY_ONCE) &#125; block() return this&#125; 使用 apply 后，我们可以在 lambda 使用 this，比如1234val str = &quot;abc&quot;str.apply &#123; println(this.length)&#125; 2.with1234567@kotlin.internal.InlineOnlypublic inline fun &lt;T, R&gt; with(receiver: T, block: T.() -&gt; R): R &#123; contract &#123; callsInPlace(block, InvocationKind.EXACTLY_ONCE) &#125; return receiver.block()&#125; with 和 apply 的区别是，需要把 receiver 显示地传给 with，比如 1234val str = &quot;abc&quot;with(str) &#123; println(this.length)&#125; 如需转载，请注明原文出处，谢谢！","categories":[{"name":"Kotlin","slug":"Kotlin","permalink":"https://zzt.github.io/categories/Kotlin/"}],"tags":[{"name":"Kotlin基础","slug":"Kotlin基础","permalink":"https://zzt.github.io/tags/Kotlin%E5%9F%BA%E7%A1%80/"}]}],"categories":[{"name":"考研","slug":"考研","permalink":"https://zzt.github.io/categories/%E8%80%83%E7%A0%94/"},{"name":"Video","slug":"Video","permalink":"https://zzt.github.io/categories/Video/"},{"name":"BlockChain","slug":"BlockChain","permalink":"https://zzt.github.io/categories/BlockChain/"},{"name":"Kotlin","slug":"Kotlin","permalink":"https://zzt.github.io/categories/Kotlin/"}],"tags":[{"name":"高数","slug":"高数","permalink":"https://zzt.github.io/tags/%E9%AB%98%E6%95%B0/"},{"name":"数据结构","slug":"数据结构","permalink":"https://zzt.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"Kotlin协程","slug":"Kotlin协程","permalink":"https://zzt.github.io/tags/Kotlin%E5%8D%8F%E7%A8%8B/"},{"name":"Kotlin基础","slug":"Kotlin基础","permalink":"https://zzt.github.io/tags/Kotlin%E5%9F%BA%E7%A1%80/"}]}